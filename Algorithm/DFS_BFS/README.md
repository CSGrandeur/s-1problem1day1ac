DFS（Depth-First-Search，深度优先搜索）和BFS（Breadth-First-Search，广度优先搜索）是两种基础的搜索方法。

所谓“搜索”，可以理解为：按照题目要求，通过某种办法高效地遍历一个图中的每一个点，求得题目的答案。

下面，我们将通过一道题来说明什么是搜索，什么是DFS，什么是BFS。

### POJ 3984：迷宫问题

#### 题目描述

定义一个二维数组：

```
int maze[5][5] = {
	0, 1, 0, 0, 0,
	0, 1, 0, 1, 0,
	0, 0, 0, 0, 0,
	0, 1, 1, 1, 0,
	0, 0, 0, 1, 0,
};
```

它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。

#### 输入

一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。

#### 输出

左上角到右下角的最短路径，格式如样例所示。

#### 输入样例

```
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例

```
(0, 0)
(1, 0)
(2, 0)
(2, 1)
(2, 2)
(2, 3)
(2, 4)
(3, 4)
(4, 4)
```

### 解题思路

走迷宫，一个直观的方法，是在每一个岔路口任选一条岔路，继续往下走。

沿着这条岔路，如果走到终点了，记下路径长度，回到上个岔路口，看看走其它岔路会不会更快；

如果没能走到终点这条岔路就断了，也是回到上个岔路口，看看走其它岔路能不能到。

这，其实就是深度优先搜索（DFS）。

我们可以按照这个基本思路，通过DFS求解本题。以下代码将详细介绍

```c++
//基本思路：DFS，走完所有分岔路后停止
//使用vis数组记录该路径下已经走过的点，以免多次走到同一个点开始绕圈
//每次到达终点，将这条路径的长度tot与记录中最短路径长度totm进行比较。若这条路径比最短路径短，更新坐标
//使用两个数组x1,y1，记录当前路径每一步的点的坐标
//使用两个数组xm,ym，记录最短路径每一步的点的坐标

#include "cstdio"
#include "cstring"
using namespace std;
int maze[5][5];//输入的迷宫地形
int vis[5][5];//记录该路径下已经走过的点
int x1[25];//记录当前路径每一步的点的纵坐标
int yk[25];//记录当前路径每一步的点的横坐标
int xm[25];//记录最短路径每一步的点的纵坐标
int ym[25];//记录最短路径每一步的点的横坐标
int tot, totm;//当前路径的长度tot，记录的最短路径长度totm

void dfs(int x, int y)
{
    if (x == 4 && y == 4)//若已到达终点
    {
        x1[tot] = 4;
        yk[tot] = 4;
        tot++;
        if (tot < totm)//若这条路径比记录的最短路径短，将最短路径更新为这条路径
        {
            for (int i = 0; i < tot; i++)
            {
                xm[i] = x1[i];
                ym[i] = yk[i];
            }
            totm = tot;
        }
        tot--;//想一想，如果不写这一行，会出现什么问题？
        return;
    }
    //若未到达终点，则将该点加入路径中，继续往下搜
    vis[x][y] = 1;
    x1[tot] = x;
    yk[tot] = y;
    tot++;
    //分别看这点上、下、左、右是否能走且没走过，可以的话沿着这那边走下去
    if (x > 0 && maze[x - 1][y] == 0 && vis[x - 1][y] == 0)
        dfs(x - 1, y);
    if (x < 4 && maze[x + 1][y] == 0 && vis[x + 1][y] == 0)
        dfs(x + 1, y);
    if (y > 0 && maze[x][y - 1] == 0 && vis[x][y - 1] == 0)
        dfs(x, y - 1);
    if (y < 4 && maze[x][y + 1] == 0 && vis[x][y + 1] == 0)
        dfs(x, y + 1);
    //四个方向都搜完，将状态回溯到来这个点之前，即回到上个岔路口
    tot--;
    vis[x][y] = 0;
};

int main()
{
    memset(vis, 0, sizeof(vis));
    int i, j;
    totm = 9999;
    tot = 0;
    for (i = 0; i < 5; i++)
        for (j = 0; j < 5; j++)
            scanf("%d", &maze[i][j]);
    dfs(0, 0);//从（0，0）点开始搜索
    for (i = 0; i < totm; i++)
        printf("(%d, %d)\n", xm[i], ym[i]);
    return 0;
}
```

可以总结出DFS的基本代码如下

```c++
dfs(搜索到的点的坐标)
{
    if (到达边界或搜索终点)
    {
        进行记录结果等步骤;
        return; //退出本次搜索
    }
    标记该点已被搜索到;
    dfs(相邻点n);
    dfs(相邻点n);
    dfs(相邻点n);
    ...... 
    dfs(相邻点n); //深度优先搜索该点的所有相邻点
    取消该点已被搜索到，标记为未被搜索的状态; //以便下次搜索时还能再次到达该点
}
```



## BFS

相对于DFS，BFS的方法并没有这么直观，但也不是很难懂。

大致的思路是：把每一个点都看成岔路口。往每一个点（岔路口）的每个方向都探一探。

如果那个方向连着另一个点（岔路口），就将那个点记录下来。

（之所以这么做，是为了以后再将它作为岔路口，往每个方向探一遍）。

将点记录下来之后，就去探当前岔路口的其它方向。如果其它的方向上也连着其它点，同样是按上述操作。探完所有方向后。则将记录中还没作为岔路口探过路的点作为岔路口探路，直至将所有点作为岔路口探完。

现在有一个问题，“应该用什么顺序，来将记录中的点作为岔路口来探路？”

如果想得到最短路径，自然需要严格按照距离起点从近到远的顺序来探路。

比如，先将距离起点距离为1的所有点探完，再探距离起点距离为2的所有点，再探距离为3、4...的点。

为什么是这样？

因为，这样可以保证：从起点出发，长度更短的路径都已经被探过了，且都到不了这个点

因此，需要严格按照距离起点从近到远的顺序来探路。

如何按照这个顺序来探路？只要建一个队列，每次从队首选择一个点来探，探到新的点就放到队尾，这样就可以一直保证靠近队首的点到起点的距离比靠近队尾的小了。

下列代码将详细介绍通过BFS求解此题的方法

```c++
#include "cstdio"
#include "cstring"
#include "queue"
using namespace std;
struct point//用结构体存储点，以方便放入队列中
{
    int x;
    int y;
};
int maze[5][5];//输入的迷宫地形
int vis[5][5];//记录点是否已（作为分岔点）探过，避免重复探一个点
point pre[5][5];//记录该点的前驱点的纵坐标

void bfs()
{
    queue<point> q;//使用队列记录待探的点
    point now;//临时变量，队首
    now.x = 0;
    now.y = 0;
    q.push(now);//先将起点（0，0）放入队列中
    while(!q.empty())//直到队列变空停止，保证将队列中所有点都探一遍
    {
        now.x = q.front().x;
        now.y = q.front().y;
        q.pop();//将队首的坐标存到now中，让队首出队

        //以下四个if分别往now点的上、下、左、右方向探，看看有没有岔路口（点）
        //有的话放到队尾，以后来探
        if (now.x > 0 && maze[now.x - 1][now.y] == 0 && vis[now.x - 1][now.y] == 0)
        {
            point p;
            p.x = now.x - 1;
            p.y = now.y;
            q.push(p);//将探到的点放到队尾
            pre[p.x][p.y] = now; //将探到的点的前驱设为now
        }
        if (now.x < 4 && maze[now.x + 1][now.y] == 0 && vis[now.x + 1][now.y] == 0)
        {
            point p;
            p.x = now.x + 1;
            p.y = now.y;
            q.push(p);
            pre[p.x][p.y] = now;
        }
        if (now.y > 0 && maze[now.x][now.y - 1] == 0 && vis[now.x][now.y - 1] == 0)
        {
            point p;
            p.x = now.x;
            p.y = now.y - 1;
            q.push(p);
            pre[p.x][p.y] = now;
        }
        if (now.y < 4 && maze[now.x][now.y + 1] == 0 && vis[now.x][now.y + 1] == 0)
        {
            point p;
            p.x = now.x;
            p.y = now.y + 1;
            q.push(p);
            pre[p.x][p.y] = now;
        }
        vis[now.x][now.y] = 1; //表明now点已经被（作为分岔口）探过了
    }
}

//由于只知道每个点的前驱，需要倒序输出。
//倒序输出有多种方法，我选择用递归，从终点一直往前找，找到起点，再依次输出。可以想想有没有更简洁的方法
void print(int x, int y)
{
    if(x == 0 && y == 0) //若找到了起点，直接输出
    {
        printf("(%d, %d)\n", x, y);
        return;
    }
    print(pre[x][y].x, pre[x][y].y); //若没到起点，先找并输出它的前驱
    printf("(%d, %d)\n", x, y); //再输出该点
}
int main()
{
    memset(vis, 0, sizeof(vis));
    int i, j;
    for(i = 0; i < 5; i++)
        for(j = 0; j < 5; j++)
            scanf("%d", &maze[i][j]);
    bfs();
    print(4, 4); //从终点往回找
    return 0;
}
```

可以总结出BFS的基本代码如下

```c++
bfs()
{
    queue<> q;    //定义一个队列来存放点
    q.push(起点); //讲起点放到队列中
    while (!q.empty())
    {
        temp = q.front();
        q.pop(); //将队列中位于队首的点取出，暂放在temp中
        q.push(temp的相邻点1);
        q.push(temp的相邻点2);
        q.push(temp的相邻点3);
        ...... q.push(temp的相邻点n);
    }
}
```



## 应用：求连通块

DFS和BFS除了被用于寻路之外，还会被用于找连通块

所谓“连通块”，可以理解为一系列相连的点

找连通块的方法非常简单，比起寻路有过之而无不及。下面我们将通过这道题来讲解连通块的求法

### POJ 3984：迷宫问题

#### 题目描述

给出一个N行M列的矩阵和K个点，问这K个点中有最多几个点相连（即最大的连通块有几个点）。

两个点“相连”，指这两个点有一条公共边，即一个点在另一个点的正上/下/左/右方


#### 输入样例

```
3 4 5
3 2
2 2
3 1
2 3
1 1
```

#### 输出样例
```
4
```

### 解题思路

DFS。对于K个点中的每一个点，判断它的四周是否有另外的点。统计每一块相连点的总数即可

```c++
#include "cstdio"
#include "cstring"
using namespace std;
int ma[105][105], n, m, k, tot;//tot：当前正在搜索的连通块中点的总数
void dfs(int r, int c)
{
    if(ma[r][c] != 1)
        return;
    tot++;
    ma[r][c] = 0;//搜索过当前点后，为避免停止搜索，将这个点标记为0
    //接下来搜索四个方向
    dfs(r + 1, c);
    dfs(r - 1, c);
    dfs(r, c + 1);
    dfs(r, c - 1);
}
int main()
{
    scanf("%d%d%d", &n, &m, &k);
    int i, j, max_tot, kr, kc;
    memset(ma, 0, sizeof(ma));
    for(i = 0; i < k; i++)
    {
        scanf("%d%d", &kr, &kc);
        ma[kr][kc] = 1;
    }
    max_tot = 0;// max_tot存储当前最大的连通块所含点个数
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
        {
            tot = 0;
            dfs(i, j);
            if(tot > max_tot)
                max_tot = tot;
        }
    }
    printf("%d", max_tot);
    return 0;
}
```



## 题单

题单中的题目都为基础的搜索，除HDU 1016之外，都可以用DFS和BFS两种方法解决

| 题目序号 | 题目出处 | 题目类型 | 题目难度 |
| -------- | -------- | -------- | -------- |
| 1        | HDU 1241 | 求连通块 | ⭐        |
| 2        | POJ 3620 | 求连通块 | ⭐        |
| 3        | POJ 3589 | 寻路     | ⭐        |
| 4        | HDU 1016 | 基础DFS  | ⭐⭐       |
| 5        | UVa 439  | 寻路     | ⭐⭐       |